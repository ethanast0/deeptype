// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { authDebug, traceSessionCheck, logAuthError } from '@/utils/authDebug';

const SUPABASE_URL = "https://mjvnjaxjilztaebmpxmy.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1qdm5qYXhqaWx6dGFlYm1weG15Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDI0MzU5MTAsImV4cCI6MjA1ODAxMTkxMH0.piNkqjJB7_7qwo0dYI2vUeeahKRZSpMuASceaeKnPTo";

// Check if we're in a browser environment
const isBrowser = typeof window !== 'undefined';

// Prevent multiple initializations
let isInitialized = false;

// Session check recovery attempts counter
let sessionRecoveryAttempts = 0;
const MAX_RECOVERY_ATTEMPTS = 3;

// Track operation sequence to help diagnose race conditions
let operationCounter = 0;

// Debounce timing for refresh operations
let refreshTimeout: NodeJS.Timeout | null = null;
const REFRESH_DEBOUNCE_MS = 2000; // Minimum time between refresh attempts
let lastRefreshTime = 0;
const MIN_REFRESH_INTERVAL_MS = 5000; // Minimum time between refresh attempts

// Custom storage wrapper to add redundancy to auth session persistence
// This helps prevent data loss if localStorage gets corrupted or cleared unexpectedly
const createRedundantStorage = () => {
  if (!isBrowser) return undefined;

  // Create a wrapper around localStorage with redundant storage
  return {
    getItem: (key: string): string | Promise<string | null> | null => {
      operationCounter++;
      const opId = operationCounter;
      try {
        const value = localStorage.getItem(key);
        
        if (value) {
          // If we successfully got the item, also store a backup
          if (key.includes('supabase.auth')) {
            localStorage.setItem(`backup:${key}`, value);
            authDebug(`[${opId}] Backed up auth item: ${key}`);
          }
          return value;
        }
        
        // If primary storage failed, try backup
        if (key.includes('supabase.auth')) {
          const backupValue = localStorage.getItem(`backup:${key}`);
          if (backupValue) {
            authDebug(`[${opId}] Restored ${key} from backup`);
            localStorage.setItem(key, backupValue);
            return backupValue;
          }
        }
        
        return null;
      } catch (e) {
        logAuthError(`[${opId}] Error getting item ${key}`, e);
        return null;
      }
    },
    setItem: (key: string, value: string): void | Promise<void> => {
      operationCounter++;
      const opId = operationCounter;
      try {
        // Store in primary localStorage
        localStorage.setItem(key, value);
        
        // Also create a backup for auth-related items
        if (key.includes('supabase.auth')) {
          localStorage.setItem(`backup:${key}`, value);
          
          // If this is a session token, store user ID separately for redundancy
          if (key === 'supabase.auth.token') {
            try {
              const data = JSON.parse(value);
              if (data?.currentSession?.user?.id) {
                // Store user ID in both primary and backup
                localStorage.setItem('supabase.auth.user.id', data.currentSession.user.id);
                localStorage.setItem('backup:supabase.auth.user.id', data.currentSession.user.id);
                
                // Also store a simplified version of the session
                storeRedundantAuthData(data.currentSession);
              }
            } catch (e) {
              // Ignore JSON parse errors
            }
          }
          
          authDebug(`[${opId}] Stored auth item with backup: ${key}`);
        }
      } catch (e) {
        logAuthError(`[${opId}] Error setting item ${key}`, e);
      }
    },
    removeItem: (key: string): void | Promise<void> => {
      operationCounter++;
      const opId = operationCounter;
      try {
        localStorage.removeItem(key);
        
        // Clean up backups for auth items too
        if (key.includes('supabase.auth')) {
          localStorage.removeItem(`backup:${key}`);
          authDebug(`[${opId}] Removed auth item and backup: ${key}`);
        }
      } catch (e) {
        logAuthError(`[${opId}] Error removing item ${key}`, e);
      }
    }
  };
};

// Create and export the Supabase client
export const supabase = createClient<Database>(
  SUPABASE_URL, 
  SUPABASE_PUBLISHABLE_KEY,
  {
    auth: {
      persistSession: true,
      autoRefreshToken: true,
      storage: isBrowser ? createRedundantStorage() : undefined,
      detectSessionInUrl: true,
      flowType: 'pkce',
      storageKey: 'supabase.auth.token' // Explicit key for localStorage
    },
    global: {
      headers: {
        'X-Client-Info': 'text-flow'
      }
    }
  }
);

// Function to store session data in redundant storage
const storeRedundantAuthData = (session: any) => {
  if (!isBrowser || !session) return;
  
  operationCounter++;
  const opId = operationCounter;
  
  try {
    if (!session) {
      authDebug(`[${opId}] Clearing redundant auth storage (session is null)`);
      localStorage.removeItem('supabase_auth_session_fallback');
      localStorage.removeItem('supabase_auth_user_fallback');
      return;
    }

    // Create a simplified version of the session for storage
    const simpleSession = {
      access_token: session.access_token,
      refresh_token: session.refresh_token,
      expires_at: session.expires_at,
      user_id: session.user.id,
    };

    const simpleUser = {
      id: session.user.id,
      email: session.user.email,
      role: session.user.role,
    };

    authDebug(`[${opId}] Storing redundant auth data`, {
      userId: session.user.id,
      expiresAt: new Date(session.expires_at * 1000).toISOString(),
    });

    localStorage.setItem('supabase_auth_session_fallback', JSON.stringify(simpleSession));
    localStorage.setItem('supabase_auth_user_fallback', JSON.stringify(simpleUser));
  } catch (error) {
    logAuthError(`[${opId}] Error storing redundant auth data`, error);
  }
};

// Function to get redundant auth data
const getRedundantAuthData = () => {
  if (!isBrowser) return null;
  
  operationCounter++;
  const opId = operationCounter;
  
  try {
    const sessionStr = localStorage.getItem('supabase_auth_session_fallback');
    const userStr = localStorage.getItem('supabase_auth_user_fallback');

    if (!sessionStr || !userStr) {
      authDebug(`[${opId}] No redundant auth data found in storage`);
      return null;
    }

    const session = JSON.parse(sessionStr);
    const user = JSON.parse(userStr);

    authDebug(`[${opId}] Retrieved redundant auth data`, {
      userId: user.id,
      expiresAt: new Date(session.expires_at * 1000).toISOString(),
    });

    // Check if session is expired
    if (session.expires_at * 1000 < Date.now()) {
      authDebug(`[${opId}] Redundant auth data is expired`, {
        expiresAt: new Date(session.expires_at * 1000).toISOString(),
        now: new Date().toISOString()
      });
      return null;
    }

    return { session, user };
  } catch (error) {
    logAuthError(`[${opId}] Error retrieving redundant auth data`, error);
    return null;
  }
};

// Helper function to clear all auth related data from local storage
export const clearAuthData = () => {
  if (!isBrowser) return;
  
  operationCounter++;
  const opId = operationCounter;
  
  try {
    authDebug(`[${opId}] Clearing all auth data from storage`);
    
    // Clear supabase storage
    localStorage.removeItem('supabase.auth.token');
    localStorage.removeItem('sb-refresh-token');
    localStorage.removeItem('supabase.auth.expires_at');
    localStorage.removeItem('supabase.auth.user.id');
    
    // Clear our redundant storage
    localStorage.removeItem('supabase_auth_session_fallback');
    localStorage.removeItem('supabase_auth_user_fallback');

    // Clear user profile
    localStorage.removeItem('user_profile');

    // Remove any additional auth items
    localStorage.removeItem('sb-access-token');
    localStorage.removeItem('sb-provider-token');
    localStorage.removeItem('supabase-auth-token');
    
    // Clear backups
    localStorage.removeItem('backup:supabase.auth.token');
    localStorage.removeItem('backup:supabase.auth.expires_at');
    localStorage.removeItem('backup:supabase.auth.user.id');
  } catch (error) {
    logAuthError(`[${opId}] Error clearing auth data`, error);
  }
};

// Safe session refresh with proper checks
export const refreshSession = async () => {
  // Check if it's too soon to refresh again
  const now = Date.now();
  if (now - lastRefreshTime < MIN_REFRESH_INTERVAL_MS) {
    console.log("[AUTH] Skipping refresh: too soon since last refresh");
    return { success: false, message: "Throttled" };
  }
  
  // Set last refresh time to prevent rapid refresh attempts
  lastRefreshTime = now;
  
  // Clear any pending refresh
  if (refreshTimeout) {
    clearTimeout(refreshTimeout);
    refreshTimeout = null;
  }
  
  try {
    // Check if we have a session first to avoid unnecessary refresh attempts
    const { data: sessionData } = await supabase.auth.getSession();
    
    if (!sessionData.session) {
      console.log("[AUTH] No session to refresh");
      return { success: false, message: "No session" };
    }
    
    // Perform the refresh
    console.log("[AUTH] Refreshing session");
    const { data, error } = await supabase.auth.refreshSession();
    
    if (error) {
      console.error("[AUTH] Session refresh error:", error);
      return { success: false, error };
    }
    
    if (!data.session) {
      console.log("[AUTH] Refresh completed but no session returned");
      return { success: false, message: "No session after refresh" };
    }
    
    console.log("[AUTH] Session refreshed successfully");
    return { success: true, session: data.session };
  } catch (error) {
    console.error("[AUTH] Session refresh exception:", error);
    return { success: false, error };
  }
};

// Get the current session
export const getCurrentSession = async () => {
  try {
    console.log("[AUTH] Getting current session");
    const { data, error } = await supabase.auth.getSession();
    
    if (error) {
      console.error("[AUTH] Error getting session:", error);
      return null;
    }
    
    if (!data.session) {
      console.log("[AUTH] No current session found");
      return null;
    }
    
    console.log("[AUTH] Current session found:", data.session.user.id);
    return data.session;
  } catch (error) {
    console.error("[AUTH] Exception getting session:", error);
    return null;
  }
};

// Initialize authentication
export const initializeAuth = () => {
  console.log("[AUTH] Initializing auth");
  
  try {
    // Check for an existing session
    const { data, error } = supabase.auth.getSession();
    
    if (error) {
      console.error("[AUTH] Error getting session during init:", error);
      return { success: false, error, cleanup: () => {} };
    }
    
    // Set up visibility change listener with debounce
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') {
        // Only refresh if it's been a while since the last refresh
        const now = Date.now();
        if (now - lastRefreshTime < REFRESH_DEBOUNCE_MS) {
          console.log("[AUTH] Skipping visibility refresh: too soon");
          return;
        }
        
        // Clear any existing timeout
        if (refreshTimeout) {
          clearTimeout(refreshTimeout);
        }
        
        // Set a small debounce for the refresh to avoid race conditions
        refreshTimeout = setTimeout(() => {
          console.log("[AUTH] Visibility changed, refreshing session");
          refreshSession().catch(e => 
            console.error("[AUTH] Error refreshing session on visibility change:", e)
          );
        }, 500); // Short debounce to allow for session rehydration
      }
    });
    
    if (data.session) {
      console.log("[AUTH] Session found during init:", data.session.user.id);
    } else {
      console.log("[AUTH] No session found during init");
    }
    
    return { success: true, session: data.session, cleanup: () => {} };
  } catch (error) {
    console.error("[AUTH] Exception during auth initialization:", error);
    return { success: false, error, cleanup: () => {} };
  }
};

// Check for persisted session
export const checkPersistedSession = async () => {
  try {
    // Try to get session from Supabase
    const { data, error } = await supabase.auth.getSession();
    
    if (error) {
      console.error("Error checking persisted session:", error);
      
      // Try recovery if Supabase getSession fails
      return attemptSessionRecovery();
    }
    
    const { session } = data;
    
    if (session) {
      // Store redundant copy
      storeRedundantAuthData(session);
      return session;
    }
    
    // Try to recover from redundant storage if no session found
    const recoveryResult = await attemptSessionRecovery();
    return recoveryResult.success ? recoveryResult.session : null;
  } catch (error) {
    console.error("Unexpected error checking persisted session:", error);
    return null;
  }
};

// Attempt to recover session from redundant storage
export const attemptSessionRecovery = async () => {
  if (sessionRecoveryAttempts >= MAX_RECOVERY_ATTEMPTS) {
    return { success: false, error: new Error('Max recovery attempts reached'), session: null };
  }
  
  sessionRecoveryAttempts++;
  
  const storedAuth = getRedundantAuthData();
  if (!storedAuth) {
    // As a last resort, check for a stored user ID
    const userId = localStorage.getItem('supabase.auth.user.id') || 
                  localStorage.getItem('backup:supabase.auth.user.id');
                  
    if (userId) {
      return { 
        success: true, 
        partial: true,
        session: { user: { id: userId } } 
      };
    }
    
    return { success: false, error: new Error('No stored auth data available'), session: null };
  }
  
  try {
    // Try to set the session using access token from redundant storage
    const { data, error } = await supabase.auth.setSession({
      access_token: storedAuth.session.access_token,
      refresh_token: storedAuth.session.refresh_token
    });
    
    if (error) {
      console.error("Error setting session from redundant storage:", error);
      return { success: false, error };
    }
    
    if (data.session) {
      // Reset recovery attempts counter on success
      sessionRecoveryAttempts = 0;
      return { success: true, session: data.session };
    }
    
    return { success: false, error: new Error('Session recovery failed') };
  } catch (error) {
    console.error("Unexpected error recovering session:", error);
    return { success: false, error, session: null };
  }
};

// Check current session before refreshing
const safeCheckAndRefreshSession = async () => {
  try {
    const { data } = await supabase.auth.getSession();
    if (!data.session) {
      console.log("No session to refresh");
      return;
    }
    
    // Session exists, check if it needs to be refreshed
    const expiresAt = data.session.expires_at * 1000;
    const now = Date.now();
    const timeUntilExpiry = expiresAt - now;
    
    // Only refresh if token expires within 15 minutes or has expired
    if (timeUntilExpiry < 15 * 60 * 1000) {
      console.log("Token expiring soon, refreshing");
      await refreshSession();
    } else {
      console.log("Token still valid, skipping refresh");
    }
  } catch (error) {
    console.error("Error during safe session check:", error);
    // If there's an error, try a normal getSession as a fallback
    await supabase.auth.getSession();
  }
};
