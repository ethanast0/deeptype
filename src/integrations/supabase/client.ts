// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { authDebug, traceSessionCheck, logAuthError } from '@/utils/authDebug';

const SUPABASE_URL = "https://mjvnjaxjilztaebmpxmy.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1qdm5qYXhqaWx6dGFlYm1weG15Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDI0MzU5MTAsImV4cCI6MjA1ODAxMTkxMH0.piNkqjJB7_7qwo0dYI2vUeeahKRZSpMuASceaeKnPTo";

// Check if we're in a browser environment
const isBrowser = typeof window !== 'undefined';

// Prevent multiple initializations
let isInitialized = false;

// Session check recovery attempts counter
let sessionRecoveryAttempts = 0;
const MAX_RECOVERY_ATTEMPTS = 3;

// Track operation sequence to help diagnose race conditions
let operationCounter = 0;

// Custom storage wrapper to add redundancy to auth session persistence
// This helps prevent data loss if localStorage gets corrupted or cleared unexpectedly
const createRedundantStorage = () => {
  if (!isBrowser) return undefined;

  // Create a wrapper around localStorage with redundant storage
  return {
    getItem: (key: string): string | Promise<string | null> | null => {
      operationCounter++;
      const opId = operationCounter;
      try {
        const value = localStorage.getItem(key);
        
        if (value) {
          // If we successfully got the item, also store a backup
          if (key.includes('supabase.auth')) {
            localStorage.setItem(`backup:${key}`, value);
            authDebug(`[${opId}] Backed up auth item: ${key}`);
          }
          return value;
        }
        
        // If primary storage failed, try backup
        if (key.includes('supabase.auth')) {
          const backupValue = localStorage.getItem(`backup:${key}`);
          if (backupValue) {
            authDebug(`[${opId}] Restored ${key} from backup`);
            localStorage.setItem(key, backupValue);
            return backupValue;
          }
        }
        
        return null;
      } catch (e) {
        logAuthError(`[${opId}] Error getting item ${key}`, e);
        return null;
      }
    },
    setItem: (key: string, value: string): void | Promise<void> => {
      operationCounter++;
      const opId = operationCounter;
      try {
        // Store in primary localStorage
        localStorage.setItem(key, value);
        
        // Also create a backup for auth-related items
        if (key.includes('supabase.auth')) {
          localStorage.setItem(`backup:${key}`, value);
          
          // If this is a session token, store user ID separately for redundancy
          if (key === 'supabase.auth.token') {
            try {
              const data = JSON.parse(value);
              if (data?.currentSession?.user?.id) {
                // Store user ID in both primary and backup
                localStorage.setItem('supabase.auth.user.id', data.currentSession.user.id);
                localStorage.setItem('backup:supabase.auth.user.id', data.currentSession.user.id);
                
                // Also store a simplified version of the session
                storeRedundantAuthData(data.currentSession);
              }
            } catch (e) {
              // Ignore JSON parse errors
            }
          }
          
          authDebug(`[${opId}] Stored auth item with backup: ${key}`);
        }
      } catch (e) {
        logAuthError(`[${opId}] Error setting item ${key}`, e);
      }
    },
    removeItem: (key: string): void | Promise<void> => {
      operationCounter++;
      const opId = operationCounter;
      try {
        localStorage.removeItem(key);
        
        // Clean up backups for auth items too
        if (key.includes('supabase.auth')) {
          localStorage.removeItem(`backup:${key}`);
          authDebug(`[${opId}] Removed auth item and backup: ${key}`);
        }
      } catch (e) {
        logAuthError(`[${opId}] Error removing item ${key}`, e);
      }
    }
  };
};

// Create and export the Supabase client
export const supabase = createClient<Database>(
  SUPABASE_URL, 
  SUPABASE_PUBLISHABLE_KEY,
  {
    auth: {
      persistSession: true,
      autoRefreshToken: true,
      storage: isBrowser ? createRedundantStorage() : undefined,
      detectSessionInUrl: true,
      flowType: 'pkce',
      storageKey: 'supabase.auth.token' // Explicit key for localStorage
    },
    global: {
      headers: {
        'X-Client-Info': 'text-flow'
      }
    }
  }
);

// Function to store session data in redundant storage
const storeRedundantAuthData = (session: any) => {
  if (!isBrowser || !session) return;
  
  operationCounter++;
  const opId = operationCounter;
  
  try {
    if (!session) {
      authDebug(`[${opId}] Clearing redundant auth storage (session is null)`);
      localStorage.removeItem('supabase_auth_session_fallback');
      localStorage.removeItem('supabase_auth_user_fallback');
      return;
    }

    // Create a simplified version of the session for storage
    const simpleSession = {
      access_token: session.access_token,
      refresh_token: session.refresh_token,
      expires_at: session.expires_at,
      user_id: session.user.id,
    };

    const simpleUser = {
      id: session.user.id,
      email: session.user.email,
      role: session.user.role,
    };

    authDebug(`[${opId}] Storing redundant auth data`, {
      userId: session.user.id,
      expiresAt: new Date(session.expires_at * 1000).toISOString(),
    });

    localStorage.setItem('supabase_auth_session_fallback', JSON.stringify(simpleSession));
    localStorage.setItem('supabase_auth_user_fallback', JSON.stringify(simpleUser));
  } catch (error) {
    logAuthError(`[${opId}] Error storing redundant auth data`, error);
  }
};

// Function to get redundant auth data
const getRedundantAuthData = () => {
  if (!isBrowser) return null;
  
  operationCounter++;
  const opId = operationCounter;
  
  try {
    const sessionStr = localStorage.getItem('supabase_auth_session_fallback');
    const userStr = localStorage.getItem('supabase_auth_user_fallback');

    if (!sessionStr || !userStr) {
      authDebug(`[${opId}] No redundant auth data found in storage`);
      return null;
    }

    const session = JSON.parse(sessionStr);
    const user = JSON.parse(userStr);

    authDebug(`[${opId}] Retrieved redundant auth data`, {
      userId: user.id,
      expiresAt: new Date(session.expires_at * 1000).toISOString(),
    });

    // Check if session is expired
    if (session.expires_at * 1000 < Date.now()) {
      authDebug(`[${opId}] Redundant auth data is expired`, {
        expiresAt: new Date(session.expires_at * 1000).toISOString(),
        now: new Date().toISOString()
      });
      return null;
    }

    return { session, user };
  } catch (error) {
    logAuthError(`[${opId}] Error retrieving redundant auth data`, error);
    return null;
  }
};

// Helper function to clear all auth related data from local storage
export const clearAuthData = () => {
  if (!isBrowser) return;
  
  operationCounter++;
  const opId = operationCounter;
  
  try {
    authDebug(`[${opId}] Clearing all auth data from storage`);
    
    // Clear supabase storage
    localStorage.removeItem('supabase.auth.token');
    localStorage.removeItem('sb-refresh-token');
    localStorage.removeItem('supabase.auth.expires_at');
    localStorage.removeItem('supabase.auth.user.id');
    
    // Clear our redundant storage
    localStorage.removeItem('supabase_auth_session_fallback');
    localStorage.removeItem('supabase_auth_user_fallback');

    // Clear user profile
    localStorage.removeItem('user_profile');

    // Remove any additional auth items
    localStorage.removeItem('sb-access-token');
    localStorage.removeItem('sb-provider-token');
    localStorage.removeItem('supabase-auth-token');
    
    // Clear backups
    localStorage.removeItem('backup:supabase.auth.token');
    localStorage.removeItem('backup:supabase.auth.expires_at');
    localStorage.removeItem('backup:supabase.auth.user.id');
  } catch (error) {
    logAuthError(`[${opId}] Error clearing auth data`, error);
  }
};

// Function to refresh the session when needed
export const refreshSession = async () => {
  operationCounter++;
  const opId = operationCounter;
  
  try {
    authDebug(`[${opId}] Attempting to refresh session`);
    const { data, error } = await supabase.auth.refreshSession();
    
    if (error) {
      logAuthError(`[${opId}] Error refreshing session`, error);
      return { success: false, error };
    }
    
    const { session } = data;
    if (session) {
      authDebug(`[${opId}] Session refreshed successfully`, {
        userId: session.user.id,
        expiresAt: new Date(session.expires_at * 1000).toISOString()
      });
      
      // Store redundant copy of the refreshed session
      storeRedundantAuthData(session);
      return { success: true, session };
    }
    
    authDebug(`[${opId}] Session refresh returned no session`);
    return { success: false, error: new Error('No session returned from refresh') };
  } catch (error) {
    logAuthError(`[${opId}] Unexpected error refreshing session`, error);
    return { success: false, error };
  }
};

// Get the current session with better error handling
export const getCurrentSession = async () => {
  operationCounter++;
  const opId = operationCounter;
  
  try {
    authDebug(`[${opId}] Getting current session`);
    const { data, error } = await supabase.auth.getSession();
    
    if (error) {
      logAuthError(`[${opId}] Error getting session`, error);
      return { success: false, error };
    }
    
    const { session } = data;
    traceSessionCheck(`getCurrentSession-${opId}`, session);
    
    if (session) {
      authDebug(`[${opId}] Got valid session`, {
        userId: session.user.id,
        expiresAt: new Date(session.expires_at * 1000).toISOString()
      });
      
      // Store redundant copy
      storeRedundantAuthData(session);
      return { success: true, session };
    }
    
    authDebug(`[${opId}] No current session found`);
    
    // Try to recover session from fallback
    const fallbackResult = await attemptSessionRecovery();
    if (fallbackResult.success) {
      authDebug(`[${opId}] Retrieved session from fallback mechanism`);
      return fallbackResult;
    }
    
    return { success: false, error: new Error('No active session') };
  } catch (error) {
    logAuthError(`[${opId}] Unexpected error getting current session`, error);
    return { success: false, error };
  }
};

// Attempt to recover session from redundant storage
export const attemptSessionRecovery = async () => {
  if (sessionRecoveryAttempts >= MAX_RECOVERY_ATTEMPTS) {
    authDebug(`Maximum recovery attempts (${MAX_RECOVERY_ATTEMPTS}) reached`);
    return { success: false, error: new Error('Max recovery attempts reached') };
  }
  
  sessionRecoveryAttempts++;
  operationCounter++;
  const opId = operationCounter;
  
  authDebug(`[${opId}] Attempting session recovery (attempt ${sessionRecoveryAttempts}/${MAX_RECOVERY_ATTEMPTS})`);
  
  const storedAuth = getRedundantAuthData();
  if (!storedAuth) {
    authDebug(`[${opId}] No stored auth data found for recovery`);
    
    // As a last resort, check for a stored user ID
    const userId = localStorage.getItem('supabase.auth.user.id') || 
                   localStorage.getItem('backup:supabase.auth.user.id');
                   
    if (userId) {
      authDebug(`[${opId}] Found stored user ID: ${userId}, but no full session data`);
      return { 
        success: true, 
        partial: true,
        session: { user: { id: userId } } 
      };
    }
    
    return { success: false, error: new Error('No stored auth data available') };
  }
  
  try {
    // Try to set the session using access token from redundant storage
    authDebug(`[${opId}] Setting session from redundant storage`, {
      userId: storedAuth.user.id
    });
    
    const { data, error } = await supabase.auth.setSession({
      access_token: storedAuth.session.access_token,
      refresh_token: storedAuth.session.refresh_token
    });
    
    if (error) {
      logAuthError(`[${opId}] Error setting session from redundant storage`, error);
      return { success: false, error };
    }
    
    if (data.session) {
      // Reset recovery attempts counter on success
      sessionRecoveryAttempts = 0;
      
      authDebug(`[${opId}] Successfully recovered session`, {
        userId: data.session.user.id,
        expiresAt: new Date(data.session.expires_at * 1000).toISOString()
      });
      return { success: true, session: data.session };
    }
    
    authDebug(`[${opId}] Session recovery did not return a valid session`);
    return { success: false, error: new Error('Session recovery failed') };
  } catch (error) {
    logAuthError(`[${opId}] Unexpected error recovering session`, error);
    return { success: false, error };
  }
};

// Initialize auth with better debugging and error handling
export const initializeAuth = async () => {
  if (!isBrowser || isInitialized) {
    return { success: false, error: new Error('Already initialized or not in browser'), cleanup: () => {} };
  }
  
  isInitialized = true;
  operationCounter++;
  const opId = operationCounter;
  
  authDebug(`[${opId}] Initializing authentication`);
  
  try {
    // Check for persisted session first
    const sessionResult = await checkPersistedSession();
    
    // Set up auth state change handler
    const { data } = supabase.auth.onAuthStateChange((event, session) => {
      authDebug(`[${opId}] Auth state changed: ${event}`, {
        hasSession: !!session,
        userId: session?.user?.id,
        event
      });
      
      if (session) {
        // Store redundant copy of session on any auth change
        storeRedundantAuthData(session);
      } else if (event === 'SIGNED_OUT') {
        // Clear auth data on sign out
        clearAuthData();
      }
    });
    
    // Set up a visibility change handler to refresh session when tab becomes visible
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') {
        authDebug(`[${opId}] Document became visible, refreshing session`);
        refreshSession().catch(error => {
          logAuthError(`[${opId}] Error refreshing session on visibility change`, error);
        });
      }
    });
    
    authDebug(`[${opId}] Auth initialization complete`, {
      foundPersistedSession: sessionResult.success
    });
    
    return {
      success: true,
      session: sessionResult.success ? sessionResult.session : null,
      cleanup: data.subscription.unsubscribe
    };
  } catch (error) {
    logAuthError(`[${opId}] Error initializing auth`, error);
    return { success: false, error, cleanup: () => {} };
  }
};

// Check for persisted session with better debugging
export const checkPersistedSession = async () => {
  operationCounter++;
  const opId = operationCounter;
  
  authDebug(`[${opId}] Checking for persisted session`);
  
  try {
    // Try to get session from Supabase
    const { data, error } = await supabase.auth.getSession();
    
    if (error) {
      logAuthError(`[${opId}] Error checking persisted session`, error);
      
      // Try recovery if Supabase getSession fails
      return attemptSessionRecovery();
    }
    
    const { session } = data;
    traceSessionCheck(`checkPersistedSession-${opId}`, session);
    
    if (session) {
      authDebug(`[${opId}] Found persisted session`, {
        userId: session.user.id,
        expiresAt: new Date(session.expires_at * 1000).toISOString()
      });
      
      // Store redundant copy
      storeRedundantAuthData(session);
      return { success: true, session };
    }
    
    authDebug(`[${opId}] No persisted session found, checking redundant storage`);
    
    // Try to recover from redundant storage if no session found
    return attemptSessionRecovery();
  } catch (error) {
    logAuthError(`[${opId}] Unexpected error checking persisted session`, error);
    return { success: false, error };
  }
};


